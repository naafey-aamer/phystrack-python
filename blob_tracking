import tkinter as tk
from tkinter import filedialog
import cv2
import numpy as np

# Global variables for drawing
drawing = False
ix, iy = -1, -1
bbox = None
frame = None
resize_width = 640  # Desired width of the resized frame
resize_height = 480  # Desired height of the resized frame
heatmap = None

def select_video_file():
    file_path = filedialog.askopenfilename()
    if file_path:
        process_video(file_path)

def draw_rectangle(event, x, y, flags, param):
    global ix, iy, drawing, bbox, frame

    if event == cv2.EVENT_LBUTTONDOWN:
        drawing = True
        ix, iy = x, y
        print(f"Mouse Down: ({ix}, {iy})")

    elif event == cv2.EVENT_MOUSEMOVE:
        if drawing:
            frame_copy = frame.copy()
            cv2.rectangle(frame_copy, (ix, iy), (x, y), (0, 255, 0), 2)
            cv2.imshow('Frame', frame_copy)

    elif event == cv2.EVENT_LBUTTONUP:
        drawing = False
        bbox = (ix, iy, x - ix, y - iy)
        print(f"Bounding Box: {bbox}")
        cv2.rectangle(frame, (ix, iy), (x, y), (0, 255, 0), 2)
        cv2.imshow('Frame', frame)

def calculate_centroid(contour):
    M = cv2.moments(contour)
    if M["m00"] != 0:
        cX = int(M["m10"] / M["m00"])
        cY = int(M["m01"] / M["m00"])
    else:
        cX, cY = 0, 0
    return cX, cY

def detect_and_track_object(file_path, bbox):
    global heatmap
    print(f"Tracking object in {file_path} with initial bounding box {bbox}")
    cap = cv2.VideoCapture(file_path)
    ret, frame = cap.read()
    if not ret:
        print("Error: Could not read frame from video")
        return

    # Initialize heatmap
    heatmap = np.zeros((resize_height, resize_width), dtype=np.float32)

    # Resize the frame
    frame = cv2.resize(frame, (resize_width, resize_height))
    print(f"Resized frame to: {resize_width}x{resize_height}")

    # Adjust bbox coordinates to match the resized frame
    bbox = (
        int(bbox[0] * resize_width / frame.shape[1]),
        int(bbox[1] * resize_height / frame.shape[0]),
        int(bbox[2] * resize_width / frame.shape[1]),
        int(bbox[3] * resize_height / frame.shape[0])
    )
    print(f"Adjusted bounding box: {bbox}")

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            print("Error: Could not read frame from video")
            break

        # Resize the frame
        frame = cv2.resize(frame, (resize_width, resize_height))

        # Crop the region of interest
        x, y, w, h = bbox
        roi = frame[y:y+h, x:x+w]

        # Convert to grayscale and apply Gaussian blur
        gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (5, 5), 0)

        # Threshold the image
        _, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

        # Find contours
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if contours:
            # Find the largest contour
            max_contour = max(contours, key=cv2.contourArea)

            # Draw the contour on the frame
            cv2.drawContours(frame[y:y+h, x:x+w], [max_contour], -1, (0, 255, 0), 2)

            # Calculate and draw centroid
            cX, cY = calculate_centroid(max_contour)
            cv2.circle(frame[y:y+h, x:x+w], (cX, cY), 5, (255, 0, 0), -1)
            # cv2.putText(frame[y:y+h, x:x+w], "centroid", (cX - 25, cY - 25), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)

            # Update heatmap
            heatmap[y:y+h, x:x+w] = cv2.add(heatmap[y:y+h, x:x+w], thresh.astype(np.float32))

        cv2.imshow('Tracking', frame)
        if cv2.waitKey(25) & 0xFF == ord('q'):
            break

    # Save heatmap as bitmap
    save_heatmap()

    cap.release()
    cv2.destroyAllWindows()

def save_heatmap():
    global heatmap
    if heatmap is not None:
        heatmap_normalized = cv2.normalize(heatmap, None, 0, 255, cv2.NORM_MINMAX)
        heatmap_colored = cv2.applyColorMap(heatmap_normalized.astype(np.uint8), cv2.COLORMAP_JET)
        cv2.imwrite('heatmap.bmp', heatmap_colored)
        print("Heatmap saved as 'heatmap.bmp'")

def process_video(file_path):
    global frame, bbox
    bbox = None
    cap = cv2.VideoCapture(file_path)
    ret, frame = cap.read()
    if not ret:
        print("Error: Could not read frame from video")
        return

    # Resize the frame
    frame = cv2.resize(frame, (resize_width, resize_height))

    cv2.namedWindow('Frame')
    cv2.setMouseCallback('Frame', draw_rectangle)

    while cap.isOpened():
        cv2.imshow('Frame', frame)
        if cv2.waitKey(25) & 0xFF == ord('q'):
            break
        if bbox is not None:
            detect_and_track_object(file_path, bbox)
            break
    cap.release()
    cv2.destroyAllWindows()

# Set up the Tkinter GUI
root = tk.Tk()
root.title('Video Object Tracker')

select_button = tk.Button(root, text='Select Video File', command=select_video_file)
select_button.pack()

root.mainloop()
