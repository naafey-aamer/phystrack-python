import tkinter as tk
from tkinter import filedialog
import cv2
import numpy as np

# Global variables for drawing
drawing = False
ix, iy = -1, -1
bbox = None
frame = None
resize_width = 640  # Desired width of the resized frame
resize_height = 480  # Desired height of the resized frame

def select_video_file():
    file_path = filedialog.askopenfilename()
    if file_path:
        process_video(file_path)

def draw_rectangle(event, x, y, flags, param):
    global ix, iy, drawing, bbox, frame

    if event == cv2.EVENT_LBUTTONDOWN:
        drawing = True
        ix, iy = x, y
        print(f"Mouse Down: ({ix}, {iy})")

    elif event == cv2.EVENT_MOUSEMOVE:
        if drawing:
            frame_copy = frame.copy()
            cv2.rectangle(frame_copy, (ix, iy), (x, y), (0, 255, 0), 2)
            cv2.imshow('Frame', frame_copy)

    elif event == cv2.EVENT_LBUTTONUP:
        drawing = False
        bbox = (ix, iy, x - ix, y - iy)
        print(f"Bounding Box: {bbox}")
        cv2.rectangle(frame, (ix, iy), (x, y), (0, 255, 0), 2)
        cv2.imshow('Frame', frame)

def detect_and_track_object(file_path, bbox):
    print(f"Tracking object in {file_path} with initial bounding box {bbox}")
    cap = cv2.VideoCapture(file_path)
    ret, frame = cap.read()
    if not ret:
        print("Error: Could not read frame from video")
        return

    # Resize the frame
    frame = cv2.resize(frame, (resize_width, resize_height))
    print(f"Resized frame to: {resize_width}x{resize_height}")

    # Adjust bbox coordinates to match the resized frame
    bbox = (
        int(bbox[0] * resize_width / frame.shape[1]),
        int(bbox[1] * resize_height / frame.shape[0]),
        int(bbox[2] * resize_width / frame.shape[1]),
        int(bbox[3] * resize_height / frame.shape[0])
    )
    print(f"Adjusted bounding box: {bbox}")

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            print("Error: Could not read frame from video")
            break

        # Resize the frame
        frame = cv2.resize(frame, (resize_width, resize_height))

        # Crop the region of interest
        x, y, w, h = bbox
        roi = frame[y:y+h, x:x+w]

        # Convert to grayscale and apply Gaussian blur
        gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (5, 5), 0)

        # Threshold the image
        _, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

        # Find contours
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if contours:
            # Find the largest contour
            max_contour = max(contours, key=cv2.contourArea)

            # Draw the contour on the frame
            cv2.drawContours(frame[y:y+h, x:x+w], [max_contour], -1, (0, 255, 0), 2)

        cv2.imshow('Tracking', frame)
        if cv2.waitKey(25) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

def process_video(file_path):
    global frame, bbox
    bbox = None
    cap = cv2.VideoCapture(file_path)
    ret, frame = cap.read()
    if not ret:
        print("Error: Could not read frame from video")
        return

    # Resize the frame
    frame = cv2.resize(frame, (resize_width, resize_height))

    cv2.namedWindow('Frame')
    cv2.setMouseCallback('Frame', draw_rectangle)

    while cap.isOpened():
        cv2.imshow('Frame', frame)
        if cv2.waitKey(25) & 0xFF == ord('q'):
            break
        if bbox is not None:
            detect_and_track_object(file_path, bbox)
            break
    cap.release()
    cv2.destroyAllWindows()

# Set up the Tkinter GUI
root = tk.Tk()
root.title('Video Object Tracker')

select_button = tk.Button(root, text='Select Video File', command=select_video_file)
select_button.pack()

root.mainloop()
